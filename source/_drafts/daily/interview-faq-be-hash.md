---
title: 知识梳理：哈希相关
date: 2019-09-23 23:02:28
updated: 2019-09-24 20:34:55
categories:
- 计算机基础

tags:
- 学习总结
---
# 前言
梳理总结哈希相关的基础概念。包括专有名词的解释：`hash 函数`，`hash 地址`（`hash code`），`hash 查找表`，`hash 表`；常见的`hash 函数`以及如何解决`hash 碰撞`的问题；简单介绍了`hash 的应用`以及关于hash从数据结构上会问的面试题。很多大数据面试题都可以利用hash的思想进行分治大任务，主要的思想是利用了通过`再hash`的输入输出数据分布一致性，且相同的内容会被hash到一台机器而不同内容会被分流到不同机器的特性，再在各台机器上对其进行处理，最后归并结果，从而起到分流的目的。

<!-- more -->
# hash
## 专有名词
- hash 函数：是一种**压缩映射**，输入空间远大于输出空间，不同的输入可能会hash成相同的输出
    - 公式：$$ 固定长度输出 = hash(任意长度的输入) $$
    - [time33算法](https://www.cnblogs.com/napoleon_liu/articles/1911571.html)：`hash(i) = hash(i-1) * 33 + str[i]` 
- hash 地址：也被叫做hash code，是hash 函数的输出，一个好的hash 函数得到的hash code应该尽可能随机分布到hash 空间（hash函数对应的值域）。
- hash map：也叫做hash表，为与hash查找表作区分，将使用hash map来作说明。hash map是一种以`键-值(key-value)`存储数据的结构，我们只要输入待查找的值即`key`，即可查找到其对应的值`value`。
    - 如果所有的`key`都是整数，那么就可以使用一个简单的无序数组来实现：将`key`作为索引，值即为其对应的值，这样就可以快速访问任意键的值。
    - 这是对于简单的`key`的情况，我们将其扩展到可以处理更加复杂的类型的`key`（如`字符串`等）的时候就需要利用到`hash函数`得到对应的`key`。
- hash **查找表**：通过`hash 函数`得到`hash map`中的`key`与`value`存储位置下标的映射关系表
    - 当 $$ key_1 \neq key_2 f \left ( key_1 \right ) = f \left ( key_2 \right ) $$ 时，发生`hash 碰撞`
- hash 地址：`hash map`中的`key`在`hash 查找表`中的下标；有时将通过hash 函数得到的值叫作`hash 地址`，有时将其值取模`hash 查找表`的长度后叫作`hash 地址`

## 常用hash函数
hash函数能使对一个数据序列的访问过程更加迅速有效，通过hash函数，**数据元素将被更快地定位**。
- 直接定址法/直接寻址法：取关键字或关键字的某个线性函数值为hash地址
- 数字分析法：找出数字的规律，尽可能利用这些数据来构造冲突几率较低的hash地址
- 平方取中法：取关键字平方后的中间几位作为hash地址
- 折叠法：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为hash地址
- 随机数法：选择一随机函数，取关键字作为随机函数的种子生成随机值作为hash地址，通常用于关键字长度不同的场合
- 除留余数法：取关键字被某个不大于hash查找表表长m的数p除后所得的余数为hash地址。即 $$ H \left ( key \right ) = key MOD p, p \leq m $$

## hash查找
使用哈希查找有两个步骤:
1. 使用哈希函数将被查找的键转换为数组的索引。在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况。所以哈希查找的第二个步骤就是处理冲突
2. 处理哈希碰撞冲突。

哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制（空间限制），那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。**只需要调整哈希函数算法即可在时间和空间上做出取舍**。

### 平均查找长度（ASL）
- 参考[Hash表的平均查找长度ASL计算方法](https://www.cnblogs.com/qixinbo/p/7782314.html)

### 装填因子
$$ \alpha = \frac{填入表中的元素个数}{散列表的长度} $$

## hash冲突
- 开放寻址法
    - 线性探测再散列
    - 二次探测再散列
    - 伪随机探测再散列
- 再散列法
- 链地址法(拉链法)
- 建立一个公共溢出区

# hash的应用
主要可用于：安全加密，唯一标识，数据校验，hash函数，负载均衡，数据分片，分布式存储

## 安全加密
### 对称加密
利用的是异或的特点：`a^b^a=a`；则在加密时：`密文 = 密钥^明文`，则`明文 = 密文^密钥 = 密钥^明文^密钥`；密钥不可公开。
- DES
- AES
- RC4

#### 消息认证码
MAC, Message Authentication Code；需要配合单向哈希实现，需要避免"重放攻击"的影响。

### 非对称加密
利用的是余数的特点，加密时：`密文 = 明文 ** E mod N`，则`明文 = 密文 ** D mod N`
加密时使用公钥（E与N的组合）加密，解密时使用私钥（D与N的组合）解密；私钥不可公开。除了常规的加解密传输消息，非对称算法还可以用于数字签名。数字签名时使用私钥加密，验证数字签名时使用公钥。
- RSA

#### 证书
提供对公钥进行数字签名，当收到它人公钥时使用CA的公钥对其进行确认，确认正确才使用里面的公钥对消息进行加密得到密文。解密时，持有私钥进行解密。

#### 混合加密
通过非对称加密沟通对称加密的密钥。非对称密钥沟通过程中利用了证书机制来验证对方的公钥。

### 单向哈希
利用单向哈希可以从任意长度数据中创建固定长度摘要信息以及不可逆的特点，可以用于保存用户的密码，对用户密码进行加密之后再存储。
- MD4/MD5
- SHA1/SHA256/SHA512

## 消息摘要
### 唯一标识
对大数据做信息摘要，通过一个较短的二进制编码来表示很大的数据。对数据进行固定点采样后通过单向哈希生成消息摘要生成唯一标识。
- 查找图库中是否存在某张图片；查找音乐库中是否存在某首歌

### 数据校验
校验数据的完整性和正确性。需要对所有的文件块取单向哈希后的哈希值，保存在BT种子文件中，逐一比较文件块的哈希值。
- 并发下载的文件在下载完成后需要将文件块进行组装，在组装时校验文件块是否完整/正确。

## hash函数
hash函数是设计一个hash查找表的关键，一个好的hash函数映射相近输入得到的输出（即：hash code）应该是尽可能随机的，hash查找表决定hash map的查找效率。

## 分布式场景
### 一致性hash
一致性hash是利用hash分布（hash(key) % N ）在取模定值N后，其分布依旧能够保持一致性的特点，将哈希空间看成一个哈希环，每个服务器节点都配置到哈希环上。
每个数据对象通过哈希取模得到的值之后，存放到哈希环中顺时针方向第一个大于等于该值的节点上。

为了解决分布不均匀的问题，引入虚拟节点，将虚拟节点映射到真实节点上。

#### 负载均衡
负载均衡利用了一致性哈希这种结构，将服务节点以及服务映射到哈希环上，服务顺时针依赖其前面的服务节点提供服务。
当服务节点发生故障需要删除时，只需要将其上的服务顺时针移到其顺时针方向上的节点即可。
当需要增加节点时，只需要将其后面的服务移到增加后的节点上即可。

#### 分布式存储
与负载均衡类似，将存储的依赖关系通过一致性hash进行分配。

### 数据分片
利用的是唯一标识符以及hash分布的特点，分解大的任务。

# 常问面试题
## Python中tuple, list, dict的区别
可以参考《[Python list、tuple、dict区别](https://www.cnblogs.com/lightwindy/p/9655026.html)》说明语法使用上的区别，在扩展说明dict的区别应该说明dict的底层实现上相较tuple与list使用直接定址法得到下标索引，使用的是hash 函数配合hash 查找表进行索引，同时应说明这种设计需要解决hash碰撞以及常见处理的方法。

## Golang中的map实现原理
- 《浅谈 Go 语言实现原理》：[3.2 哈希表](https://draveness.me/golang/datastructure/golang-hashmap.html)
- [由浅入深聊聊Golang的map](https://blog.csdn.net/u011957758/article/details/82846609)

数据结构：hash查找表使用的是基于位图的思想，先得到key所在的bucket，然后使用tophash通过高八位的topbits获得待查询的键值对在bucket中的具体位置，解决碰撞的方法是"拉链法"。

### Golang中map的扩容缩容过程

## Redis中的渐进式哈希原理
Redis作为键值类型的数据库，底层实现利用的是hash map，涉及扩容，缩容操作。
- [redis渐进式rehash机制](https://www.cnblogs.com/williamjie/p/11205593.html)

# 参考资料
- [【算法】理解哈希算法 hash 和常见应用](https://blog.csdn.net/sscc_learning/article/details/88658511)
- [密码技术简明教程(一)：对称加密和非对称加密](https://jiajunhuang.com/articles/2019_05_12-crypto.md.html)
- [密码技术简明教程(二)：散列、消息认证码和数字签名](https://jiajunhuang.com/articles/2019_05_14-crypto_part2.md.html)
- [密码技术简明教程(三)：证书和TLS](https://jiajunhuang.com/articles/2019_05_15-crypto_part3.md.html)
- [CS-Notes/notes/缓存.md - 七、一致性哈希](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#%E5%85%AD%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83)

# Changelog
- 2019/09/24：第一版内容
- 2019/10/18：添加[Redis中的渐进式哈希原理](#Redis中的渐进式哈希原理)
