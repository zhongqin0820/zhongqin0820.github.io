---
title: 知识梳理：操作系统进程管理相关
date: 2019-05-29 10:47:11
updated: 2019-06-30 21:03:48
categories:
- 计算机基础

tags:
- 学习总结
---
# 前言
梳理总结进程管理相关的基础概念，包括：临界资源与临界区，进程通信与进程同步，线程通信与线程同步以及针对一些混淆名词的对比梳理。最后总结并发模式相关内容：并发IO中的`select`, `poll`, `epoll`。

<!-- more -->
# 基本概念
## 临界资源与临界区

|名词|说明|
|:---:|---|
|临界资源|即共享内存中的内容|
|临界区|与临界资源操作相关的代码段|
|加锁|使多个进程对临界区的临界资源的访问是互斥的<br>（即：任一时刻，只有一个进程可以进入临界区访问临界资源）|

## 专有名词梳理
- 串行与并行
    - 串行：程序按照某种调度算法，顺序执行，但是可能带来的问题是，由于CPU执行速度远快于IO操作，因此当程序进行IO操作时，串行程序在时间上会浪费CPU的资源（CPU需要等待IO操作的完成）。因此，**时间片轮转**调度算法将CPU按时间片出让给程序，同时利用**并发技术**合理充分利用CPU资源。
    - 并行：前提条件是可以有多个CPU运行多个程序，每个程序在执行时通常独占该CPU的资源。

- 并发与并行
    - 并发：一种技术手段，尽最大限度利用CPU资源。与时间片轮转算法息息相关，表现为在某个时间段內，所有的程序好像同时在执行，但实际上，可能每个时刻只有一个程序被调度（如果是并行的程序，则每个时刻可以有多个程序被调度）。
    - 并行：表现为任一时刻，多个程序同时执行，因此并行的前提是多核而并发。

- 同步与异步：
    - 二者都为并发程序的**执行表现**
    - 同步：并发程序按照某种约定的顺序进行执行，如果不对其进行控制，则结果不可重现
    - 异步：程序的执行，当遇到IO操作的时候，通常不要求立即返回结果，调用该操作的程序会继续执行。

- **阻塞与非阻塞**：
    - **任一时刻**，一个CPU核心上只可以运行一个进程。但是可以利用**调度算法**使其在一段时间内运行**多个进程**。
    - 调度算法（以CPU时间片轮转算法为例）通常与**进程状态**（【新建】；【就绪】->【运行】->【等待】；【终止】）以及【系统调用，中断】相关联。
        - 【系统调用，中断】引起正在【运行】进程的【阻塞】，这种状态的改变会导致CPU空闲，调度算法合理调度就绪进程充分利用空闲CPU资源（即进程切换）。
    - 进程的切换通常涉及上下文的切换，需要将旧/新进程的上下文（程序计数器，寄存器内容）对应载入/载出内存（PCB）。
    - 阻塞通常是进程发起一个【系统调用】时（通常是IO操作），调用者由于需要等待系统调用返回的结果，将自己挂起（或阻塞）进入【等待】状态，出让CPU给其它进程。
    - 关于阻塞的讨论，需要在IO模型与进程通信中分别进行讨论：
        - 阻塞：当【系统调用】未返回结果时，调用进程不接着执行；区分于在进程通信中，同步通常意味着阻塞。
        - 非阻塞：【系统调用】未返回结果时，调用进程接着执行，通常伴随使用轮询的机制检查结果是否可用；区分于在进程通信中，异步通常意味着非阻塞。

## 进程通信与进程同步
- 同步是**并发程序**按照某种顺序（通过约定的通信方式）**有序访问临界资源**的目的，需要借助通信手段达到。
- 通信是**并发程序**达到同步的手段，包括：
    - 管道（有名、无名）
    - 共享内存与信号量
        - 信号量（锁）：当信号量变量值取值范围为`0`或`1`时被称为"互斥量"/"互斥锁"
        - 共享内存（程序读写的内容）
    - 信号：`os.SIGNAL`
    - `socket`：异构系统之间的通信方式

## 线程通信与线程同步
由于线程是CPU直接调度的基本单位，需要依赖于进程存在。因此线程的通信手段包括：
- IPC通信
- 线程上下文
- 信号量与共享内存
- 信号：略与进程的接口不同
- `socket`：略与进程的接口不同

## 并发IO
> Unix 中内置了 5 种 IO 模型，阻塞式（Blocking） IO, 非阻塞式（Non-Blocking） IO（NIO），IO 复用模型，信号驱动式 IO 和异步（Asynchronous） IO。其中 Blocking 与 Synchronous 大同小异，而 **NIO 与 Async 的区别在于 NIO 强调的是 轮询（Polling），而 Async 强调的是通知（Notification）**。
> **王下月邀熊** --- <cite>[并发编程导论](https://segmentfault.com/a/1190000018949353)</cite>

- 针对IO模型中的区分，非阻塞IO与异步IO都属于非阻塞系统调用
    - 同步阻塞IO：在此种方式下，用户进程在发起一个 IO 操作以后，必须等待 IO 操作的完成，只有当真正完成了 IO 操作以后，用户进程才能运行。
    - 同步非阻塞IO：在此种方式下，用户进程发起一个 IO 操作以后边可返回做其它事情，但是用户进程需要时不时的询问 IO 操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的 CPU 资源浪费。
    - 异步IO：在此种模式下，用户进程只需要发起一个 IO 操作然后立即返回，等 IO 操作真正的完成以后，应用程序会得到 IO 操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的 IO 读写操作，因为真正的 IO 读取或者写入操作已经由内核完成了。

- IO 多路复用通过一种机制，可以监视多个描述符，一旦某个描述符就绪(一般是读就绪或者写就绪)，能够通知程序进行相应的读写操作。常见IO多路复用的机制包括以下三种，本质上属于阻塞式读写。
    - select：轮询式，每次调用 select 都要在用户空间和内核空间里进行内存复制 fd 描述符等信息
    - poll：突破了 select 中描述符数目的限制
    - epoll：在传递内核与用户空间的消息时使用了内存共享，而不是内存拷贝
        - 通过基于内核提供的反射模式，有活跃 Socket 时，内核访问该 Socket 的 callback，**不需要遍历轮询**，分为：
        - 水平触发
            - 与select，poll的机制差不多
            - 读就绪：缓冲区不空
            - 写就绪：缓冲区不满
        - 边缘触发
            - 读就绪：缓冲区不可读变可读或者有新数据到来
            - 写就绪：缓冲区不可写变可写或者有就数据被取走

# 参考资料
- [Linux IO模式及 select、poll、epoll详解](http://blog.taohuawu.club/article/linux-io-select-poll-epoll)
- [进程、线程知识点总结和同步（消费者生产者，读者写者三类问题）、互斥、异步、并发、并行、死锁、活锁的总结](https://www.cnblogs.com/kubixuesheng/p/4355786.html)
- [并发编程导论](https://segmentfault.com/a/1190000018949353)
- [当我们在谈论高并发的时候究竟在谈什么?](https://segmentfault.com/a/1190000019360335)
- [怎样理解阻塞非阻塞与同步异步的区别？ - 萧萧的回答 - 知乎](https://www.zhihu.com/question/19732473/answer/241673170)

# Changelog
- 2019/06/11：添加针对基础概念的梳理，以及相关参考资料链接
- 2019/06/13：添加[Linux IO模式及 select、poll、epoll详解](http://blog.taohuawu.club/article/linux-io-select-poll-epoll)。
- 2019/06/30：重新拆分，整理格式