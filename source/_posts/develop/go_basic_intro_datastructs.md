---
title: Go语言入门总结:基础数据结构
date: 2018-06-22 11:47:10
updated: 2018-06-22 11:47:10
categories:
- 网页开发

tags:
- Go
---
## 前言
梳理总结学习Go语言的笔记：基础数据结构（数组、切片、映射）

<!-- more -->
## 数组`array`
### `range`表达式
&emsp;&emsp;`range`表达式遍历有两个返回值，第一个是索引，第二个是元素的值
&emsp;&emsp;它可以被用在数组`array`、哈希结构`map`。
### 值传递与引用传递
&emsp;&emsp;数组作为函数的参数仍然是值传递，虽然可以使用数组的指针来代替，但是改变不了数组长度。这时，我们通常使用切片`slice`来替代数组。
&emsp;&emsp;**数组是定长的，而切片则是不定长的。前者是值拷贝，后者是引用拷贝**
## 切片`slice`
&emsp;&emsp;三种创建方式： 基于底层数组创建，直接创建，或者 `make()` 函数创建
&emsp;&emsp;`slice`是对底层数组的抽象和控制。它包含 `Go`需要对底层数组管理的三种元数据，分别是：
1. 指向底层数组的指针
2. `slice`中元素的长度
3. `slice`的容量(可供增长的最大值)

### `make()`函数
&emsp;&emsp;函数`make()`可以用于灵活的创建数组切片。`make()`函数创建一个指定元素类型、长度和容量的`slice`。
&emsp;&emsp;容量部分可以省略，在这种情况下，容量将等于长度。
### `len()`与`cap()`函数
&emsp;&emsp;内置的`len()`函数获取长度，内置的`cap()`函数获取容量。
### 切片不能比较
&emsp;&emsp;与数组不同的是`slice`之间不能比较，因此我们不能使用`==`操作符来判断两个`slice`是否含有全部相等的元素。
&emsp;&emsp;不过标准库提供了高度优化的`bytes.Equal()`函数两个字节型`slice`是否相等，但是对于其它类型的`slice`，我们必须自己展开每个元素进行比较。
&emsp;&emsp;**切片可遍历，可修改，不可比较**
### 追加元素
&emsp;&emsp;内置的`append()`函数用于向`slice`追加元素。
&emsp;&emsp;可以直接追加元素，也可以追加一个`slice`。
&emsp;&emsp;注意参数`slice`后有`...`。否则有语法错误。
&emsp;&emsp;因为`append()`函数的语义是从第二个参数开始都应该是待附加的元素。
&emsp;&emsp;`slice`后加`...`意味将`slice`的元素全部打散后传入。数组切片会自动处理存储空间不足的问题。如果追加的内容长度超过当前已分配的存储空间（即`cap()`调用返回的信息），**数组切片会自动分配一块足够大的内存**。
### 复制
&emsp;&emsp;内置的`copy()`函数用于数组切片的复制。复制时无需考虑目标数组和源数组的长度。
### 字符串和`byte`切片
&emsp;&emsp;标准库中提供了4个与字符串操作相关的包：

| 包       | 功能                                       |
| ------- | ---------------------------------------- |
| strings | 提供了字符串查询、替换、比较、截断、拆分和合并等功能。              |
| bytes   | 提供了很多与strings包类似的功能。因为字符串是只读的，逐步构建字符串会导致很多分配和复制，这种情况下，使用bytes.Buffer类型将会更有效。 |
| strconv | 提供了布尔类型、整数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。 |
| unicode | 提供了IsDigit、IsLetter、IsUpper和IsLower等功能，用于给字符分类。 |
## 映射`map`
&emsp;&emsp;`Map`通常称为 字典`dictionary`或者哈希表`Hash table`。使用字面值是创建`map`惯用的方法
&emsp;&emsp;映射是一个**无序的键值对集合**，其中所有的键都是不同的，然后通过给定的键可以在常数时间复杂度内检索、更新或删除对应的值
### 在映射中查找元素
&emsp;&emsp;需要知道对应的元素是否在`map`中
```go
v,ok:=map[key]
if !ok{
/*在map中不存在key为键的元素*/
}

//结合起来使用
if v,ok:=map[key];!ok{
/*    */
}
/*
map下标语法将产生两个值；布尔变量一般命名为ok。
*/
```
&emsp;&emsp;**第二个值是一个布尔类型，用于表示元素是否存在。**
### 遍历映射
&emsp;&emsp;由于`map`是无序的集合，所以每次遍历的顺序可能不一样。
### 初始化
&emsp;&emsp;`slice`，`function` 和 包含 `slice` 的 `struct` 类型不可以作为 `map` 的键，否则会编译错误
### 元素删除
&emsp;&emsp;使用内建函数`delete(map, key)`删除元素

## 结束语
&emsp;&emsp;对于引用类型的切片和映射(map)，需要注意对其进行`for range`迭代时，对其进行增删将会影响其遍历的迭代器指向。

## 参考链接
- [基础数据结构](https://www.jb51.net/article/56828.htm)
